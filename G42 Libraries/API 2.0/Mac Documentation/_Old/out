Documentation for using the Group 42 Image Sdk version 2.0 Beta 5
The library consists of seven major classes.
The G42Image class holds the image data and information,
as well as provides some basic modification abilities for
the data (color reduction and resizing).  Its header file
is g42image.h
The G42OptimizedPalette class optimizes a palette for an
image or creates a standard palette to be used when color
reducing an image.  Its header file is g42opal.h
The G42ImageFile class processes raster file information (typically
from a disk file) and puts the resulting raster image into a
G42Image.  Its header file is g42ifile.h
The G42Data class handles the image data, swaping out to a
temporary file when necessary.  Its header file is g42memry.h
There are two classes derived from G42ImageViewer, which
view files.  The first is G42SimpleViewer which merely
draws an image on a window.  The second is G42ZoomViewer, which
handles zooming, scrollbars, and dithering.  G42SimpleViewer is
in g42iview.h and G42ZoomViewer is in g42zview.h
The G42ImageWriter class writes a G42Image to a file.  You pass
in the image and the file, and it writes it.  The G42Image class
has the ability to set some of the values used to determine which
type of image to write (like SetImageType and SetProgressive, etc.).
If you want to save different bit depths then what the image currently
is, you will have to do a ColorReduce on the image (or perhaps on a
copy of the image).
The G42Image class holds the raster data and some information
about the file.  For the most part, other classes act on the
image class.  However, there are a few things that can be
done directly to the image class.  You can get the image
information with a GetInfo() call.  Be sure to query HasInfo()
first, or the library will crash.  You can also Resize() or
ColorReduce() the image.  You can call IsValid and IsFinished
also, to get status on the image as it is being read in.
The image class has an operator = and a copy constructor, so
new images can be made off of old images.  This is a reasonably
fast operation, so feel free to use this when convenient.
The G42OptimizedPalette class generates optimized and standard
palettes for images.  If you are doing a large number of dithers,
it will be faster to create a palette and pass it into the
ColorReduce() function.  For example, if my view returns a
screen mode of Palette256, I tend to do:
	DitherPalette = new G42OptimizedPalette(0, 256, false, true);
and then for each image I need dithered, I can just:
	Image->ColorReduce(DitherPalette);
and I can set up the simple viewer windows palette with
	View->SetWindowsPalette(DitherPalette->GetPalette(),
	DitherPalette->GetNumPalette());
When I need to know the image dimensions, I get them like this:
	if (Image->HasInfo())
	{
		uint32 width = Image->GetInfo().Width;
		uint32 height = Image->GetInfo().Height;
		etc.
	}
If I'm going to be calling GetInfo() alot, I sometimes do:
	const G42ImageInfo & info = Image->GetInfo();
after which I can just refer to info.Width and info.Height
One warning.  The PixelDepth field of G42ImageInfo can change
values across operating systems on TrueColor images, so it is
strongly suggested you check the ColorType field for ColorTypeTrueColor
instead of checking PixelDepth for 24 or 32 (although I do sometimes
check for PixelDepth > 8).
To read a file, first create a blank G42Image, then create
a G42ImageFile and pass in the G42Image to put the data in.
As you get data, call ProcessData in the G42ImageFile.  When
the file is finished, IsFinished will return true.  If IsValid
returns false, the data is invalid.  Be sure to check IsValid
as you read the image in, as IsFinished will never return true
on an invalid file.  If you run out of data, but IsFinished is not
returning true (probably a truncated file), you can call
ForceFileEnd to mark the image finished.  If you call ForceFileEnd
on an already finished file, it just returns immediately, so it
is a safe call.  The following sample code is for reading
from a disk file.  It will need to be modified for other cases.
The image holds information about the file size and modification
time.  These fields are not used in the library, and will need
to be set if you wish for them to be valid.  The code below
sets these fields correctly.
// read a file in.  Returns image, or 0 if not valid
G42Image * ReadFile (const char * file_path)
{
	// set up a buffer to read into.  I'm using 4k somewhat randomly,
	// although getting the buffer too small will degrade performance
	uint buf_size = 4096;
	byte * buf = new byte [buf_size];
	if (!buf)
		return 0;
	FILE * fp = fopen(file_path, "rb");
	if (!fp)
	{
		delete[] buf;
		return 0;
	}
	G42Image * image = new G42Image(MemoryManager);
	if (!image || !image->IsValid())
	{
		delete[] buf;
		fclose(fp);
		return 0;
	}
	G42ImageFile reader(image);
	if (!reader.IsValid())
	{
		delete[] buf;
		fclose(fp);
		delete image;
		return 0;
	}
	while (reader.IsValid() && !reader.IsFinished())
	{
		uint size = fread(buf, 1, buf_size, fp);
		if (!size)
			break;
		reader.ProcessData(buf, size);
	}
	reader.ForceFileEnd(); // in case we haven't reached the end yet
	if (reader.IsValid())
	{
		// set up file size and modified time in image information
		struct stat stat_buf;
		fstat(fileno(fp), &stat_buf);
		Image->SetInfoFileSize(stat_buf.st_size);
		Image->SetInfoModifiedTime(stat_buf.st_mtime);
	}
	else
	{
		delete image;
		image = 0;
	}
	fclose(fp);
	delete[] buf;
	return image;
}
The image data itself is stored in a temporary file with a memory cache
connected.  You will need to create the memory manager before you create
any images, and destroy them after the last image has been destroyed.
The class that handles all the details is G42Data.  Create this when
your program starts, and destroy it when it finishes.  If the program
crashes, a temporary file may be left on the machine, depending upon
the operating system.
The simple way to view images is to use the G42SimpleViewer class.
This class simply draws the image (or portions thereof) on a screen.
You are required to do all the work to remember where, when, and
how to draw the image.  Help is provided to control the colormap,
but you have to provide the palette and dither any images to it.
(new for Beta 5)
Specifically, you can find out what screen type you are on by doing
a GetScreenType() on the viewer.  You will then have to create a
palette (see the example above for G42OptimizedPalette), and dither
each image to that palette.  You will also need to tell the view what
palette you are using through a SetWindowsPalette() call, passing in
the optimized palette info.  The only exception will be monochrome
images, which don't need dithered (The function won't do anything).
I plan to have a multiple image viewer soon, and I expect most people
will be using that instead of SimpleImageViewer, with the possible
exception of printing, which is what SimpleImageViewer was originally
designed for anyway (besides being a base class for the other viewers).
A nice step up is the G42ZoomViewer.  This class does zooming, panning,
scrollbar control, palette control, redrawing, etc. for a single image.
When you create it, you need to tell it both the window it is drawing
upon and the top level window which contains it (the one that the
operating system puts the decorations on).  This top window is usually
the main window of the application or dialog, and is used for colormap
control.  You will need to capture the following messages and call
the corresponding functions in the viewer:  WM_SIZE, WM_HSCROLL,
WM_VSCROLL, WM_QUERYNEWPALETTE, WM_PALETTECHANGED.  If the function
returns a value, return that to the operating system.  You will also
need to call Draw() on a WM_PAINT.  If you wish, you can detect the
rectangle you need to draw into, and pass that along with the HDC
into the Draw function.  If you change the image, you might have
to call Rebuild and Draw (although I'm working on a way to remove
that requirement).  In certain cases, the class draws a rough image
immediately, and draws a much smoother image in the background.  If
you want the smoother image, you will need to call IdleAction when
nothing else is happening.  Keep calling IdleAction until it returns
false.  Be sure to call it again if anything changes.  I believe that
you must call IdleAction at least once on 8 bit paletted screens.
I may change this eventually, but for speed purposes, I'd rather do
more processing in the background, so the user can get an image up
sooner.  I will probably put a mode on this viewer, so you can decide
how you want the image drawn (quickly, quality, both with idle action).
Writing images is even simpler then reading.  To write an image, you
create a G42ImageWriter passing in the image and a file name.  After
checking the writer to see if it is valid (which should always be true
unless you have a memory problem), you call WriteImage() to write the
image.  If the image writes successively, IsFinished() will return true.
If it doesn't, there was an error somewhere.
	G42ImageWriter writer(Image, FilePath);
	if (writer.IsValid())
	{
		writer.WriteImage();
		if (!writer.IsFinished())
		{
			MessageBox(0, "Unable to Write File", "Error", MB_OK);
			return false;
		}
	}
The G42Image class has options to indicate the type of image you
wish to write, as well as other options like compression and
progressive display.  When you start modifying the image in this way,
you may want to make a copy of the image and modify that instead.  For
example:
	G42Image image(*Image); // note that Image is a pointer
	image.SetImageType(type); // one of the G42ImageType enum in g42itype.h
	image.SetProgressive(progressive); // true or false
	image.SetCompression(compression); // see g42itype.h
	// these last two you can let default if you wish
	image.SetJpegQuality(jpeg_quality); // 90 is a good default
	image.SetJpegSubSampling(jpeg_sub_sampling); // true (typically) or false
Also, if you wish to change the number of colors in an image or the color
type, you can do this through a ColorReduce call (see the discussion about
G42Image).  Note that GIF files must not be TrueColor (the library will
refuse to write them).  If the file was read as a GIF and not ResizeImage()'ed
(zooming is ok, as it doesn't modify the image itself), you don't have to
worry.  However, if you are converting from JPEG or BMP or another format,
you will have to check this.  Here is some code I use to verify this.
Note that transparent GIF's must only have 255 colors.  The ColorReduce
call automatically reduces the number of colors if the image is transparent,
to give room for the transparent pixel.
	if (Image->GetInfo().ImageType == Gif &&
		(Image->GetInfo().ColorType ==
			G42ImageInfo::ColorTypeTrueColor) ||
		(Image->GetInfo().ColorType ==
			G42ImageInfo::ColorTypePalette &&
			Image->GetInfo().IsTransparent &&
			Image->GetInfo().NumPalette == 256))
	{
		G42Image image(*Image);
		int num = 256;
		image.ColorReduce(MethodDither, Color, num);
		G42ImageWriter writer(&image, GetDocPath());
		if (writer.IsValid())
			writer.WriteImage();
		if (!writer.IsFinished())
		{
			MessageBox(0, "Unable to Write File", "Error", MB_OK);
			return false;
		}
	}
The following code fragments are from my test program.
This is in my constructor:
	// be sure we put scroll bars on
	Attr.Style |= WS_HSCROLL | WS_VSCROLL;
	// start up the memory manager
	MemoryManager = new G42Data();
This is in my destructor:
	// delete the zoomed view
	if (ZoomView)
	{
		delete ZoomView;
		ZoomView = 0;
	}
	// delete the simple view
	if (SimpleView)
	{
		delete SimpleView;
		SimpleView = 0;
	}
	// delete the image
	if (Image)
	{
		delete Image;
		Image = 0;
	}
	// delete the memory manager last
	delete MemoryManager;
Two examples of handling WM_PAINT
	// repaint zoomed view
	ZoomView->Draw();
	// draw an image
	SimpleView->DrawImage(dc, Image,
		rect.left, rect.top, rect.right - rect.left,
		rect.bottom - rect.top,
		G42ZoomInfo(), 0, 0);
I tend to give the user a redraw function, partially in case
something happens and the image gets a little confused, partially
because it's very useful in testing.
	ZoomView->Rebuild();
In this program, I'm reading in the idle action stuff, so
when we are adding an image, I just set up everything here.
	// delete old image and reader
	if (Reader)
	{
		delete Reader;
		Reader = 0;
	}
	if (Image)
	{
		delete Image;
		Image = 0;
	}
	// create new image
	Image = new G42Image(MemoryManager);
	if (!Image)
	{
		return;
	}
	// create new reader
	Reader = new G42ImageFile(Image);
	if (!Reader || !Reader->IsValid())
	{
		return;
	}
	if (!ReadBuffer)
	{
		ReadBuffer = new byte [ReadBufferSize];
	}
	if (ReadFP)
	{
		fclose(ReadFP);
	}
	ReadFP = fopen(file_path, "rb");
	// tell the view what image to display
	ZoomView->SetImage(Image);
Here is my idle action code
	// if we are reading in a file currently
	if (Reader)
	{
		int size = fread(ReadBuffer, 1, ReadBufferSize, ReadFP);
		if (size)
		{
			Reader->ProcessData(ReadBuffer, size);
		}
		else // truncated file?
		{
			// check to see if we got any part of the image in
			if (Image->IsValid() &&
				Image->HasInfo())
			{
				// force the end of the file
				Reader->ForceFileEnd();
			}
			else
			{
				// invalid file, quit
				delete Reader;
				Reader = 0;
				fclose(ReadFP);
				ReadFP = 0;
				delete Image;
				Image = 0;
			}
		}
		// if finished normally
		if (Reader && Reader->IsFinished())
		{
			delete Reader;
			Reader = 0;
			fclose(ReadFP);
			ReadFP = 0;
		}
		// return true even if finished reading
		return true;
	}
	// call the display idle.  It returns true if we need more
	return ZoomView->IdleAction();
I tend to create my views in the setup window message, as the
HWINDOW parameters are valid, which I need to create the view.
	ZoomView = new G42ZoomImageViewer(*this,
		*(GetApplication()->GetMainWindow()));
	SimpleView = new G42SimpleImageViewer(*this,
		*(GetApplication()->GetMainWindow()));
These next calls handle certain windows messages of the same name.
You will have to crack the lparam and wparam yourself if your
framework doesn't do it for you.
	// handle WM_SIZE
	ZoomView->WindowSizeChanged();
	SimpleView->WindowSizeChanged();
	// handle WM_QUERYNEWPALETTE
	return ZoomView->QueryNewPalette();
	return SimpleView->QueryNewPalette();
	// handle WM_PALETTECHANGED
	ZoomView->PaletteChanged(who);
	SimpleView->PaletteChanged(who);
	// these are WM_HSCROLL and WM_VSCROLL
	ZoomView->ProcessHScrollBarCode(scrollCode, thumbPos);
	ZoomView->ProcessVScrollBarCode(scrollCode, thumbPos);
Happy coding.
-Guy
