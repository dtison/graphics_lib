/*==================================================================	File:          		CommImageView.cp   © 1996, Group 42	Description:		Subclass of LView for Image display	Author:				David Ison	Creation Date: 		26 Jan. 1996	Modification History:		Code   Date   Name and Description				6-96	Created===================================================================*/#include "CommImageView.h"#include <LString.h>#include <stdio.h>#include "g42ifile.h"#ifdef USE_THREADS#include <LThread.h>#ifndef __THREADS__#include <Threads.h>#endif#endif#include "CommProgress.h"#include "g42march.h"#include "CommProHandler.h"short CommImageView::sWindowBorder = 10;// Temporary things [until I get them really figured out]#define BUFFER_SIZE 	80// End temporary things//#define USE_PROFILER#ifdef USE_PROFILER#include <profiler.h>Boolean ProfilerInitialized = false;#endif/*-------------------------------------------  CommImageView Constructor --------------------------------------------*/CommImageView::CommImageView (LStream *inStream): PaletteSet (false), 	ImageFile (0),	DisplayGWorld(0), Zoom (1.0), GImage (0), Window (0), Scroller (0), 	#if 0	WaitCursor (false), 	#endif	SingleImageView (0), 	LastCursorX (0), LastCursorY (0),	LastClickTime (0), ClickCount (0),	LView (inStream){	FileSpec.name [0] = 0;}/*-------------------------------------------  Do the usual orderly throw-away routine.. --------------------------------------------*/CommImageView::~CommImageView (void){	if (SingleImageView)	{		delete SingleImageView;		SingleImageView = nil;	}	if (GImage)	{		delete GImage;		GImage = nil;	}	#ifdef USE_PROFILER	ProfilerDump ("\pDrawing.prof");	ProfilerClear();	#endif}#if 0/*-----------------------------------------------------------------------------SetImageFile Initializes the G42Image reader, gets the image size, and resizes "ourself" to it. ------------------------------------------------------------------------------*/Boolean				CommImageView::SetImageFile (LCommander *commander, LFile *file, 	G42Data *dataCore, G42SingleImageViewer *singleViewer, 	CommProHandler *progressHandler){ 	short		fileRef;	bool		done = false;	long		bufferSize = ImageBufferSize;	Ptr			buffer;	Commander = commander;	/*  Step 1:  Set up file & read image  */	ImageFile = file;	ImageFile -> OpenDataFork (fsRdWrPerm);	fileRef = ImageFile -> GetDataForkRefNum();			long bytesToRead, bytesRead = 0;	::GetEOF (fileRef, &bytesToRead);	buffer = new char [bufferSize];	// Error handling	GImage = new G42Image (dataCore, (G42EventUpdateHandler *) progressHandler);	#if 0	WaitCursor = CCursor::SetWaitCursor();	#endif	G42ImageFile reader (GImage);	if (progressHandler)	{		progressHandler -> SetDenominator (bytesToRead);		progressHandler -> Start();	}				while (reader.IsValid() && ! reader.IsFinished() && bytesRead < bytesToRead)	{		#if 0		long memBytes = ::MaxBlock();		if (memBytes < 100000)		{			SysBeep (0);			G42MacFile::Msg ("\pGetting low on memory");			ExitToShell();			}		#endif		FSRead (fileRef, &bufferSize, buffer);				bytesRead += bufferSize;		reader.ProcessData ((byte *) buffer, bufferSize);			if (progressHandler)			progressHandler -> Set (bytesRead);	}//	#define TESTING	#ifdef TESTING	/*  Create a window and draw into it instead  */	LWindow *bigWindow = LWindow::CreateWindow (1102, nil);	GrafPtr port = bigWindow -> GetMacPort();	SetPort (port);	#endif	reader.ForceFileEnd();	file -> CloseDataFork ();	if (progressHandler)		progressHandler -> Stop();	/*  Take care of a couple of info fields  */		GImage -> SetInfoFileSize (bytesRead);	#if 0	HFileParam fileParam;	memset (&fileParam, 0, sizeof (fileParam));	fileParam.ioVRefNum = fileRef;	PBGetFInfoSync ((ParamBlockRec *) &fileParam);	GImage -> SetInfoModifiedTime (fileParam.ioFlMdDat);	#else	GImage -> SetInfoModifiedTime (0);	#endif	SingleImageView = singleViewer;	SingleImageView -> SetImage (GImage, false);		delete [] buffer;	return true;}	#endifBoolean				CommImageView::SetImage (LCommander *commander, G42Image *image, 	G42SingleImageViewer *singleViewer){ 	Commander 		= commander;	GImage 			= image;	SingleImageView = singleViewer;	return true;}	/*------------------------------------------------------------------------------	DrawSelf is responsible for all drawing -------------------------------------------------------------------------------*/void CommImageView::DrawSelf (void){	if (SingleImageView)	{		/* 	Step 1:  Synchronize view to scroll positions */		SPoint32 pos;		GetScrollPosition (pos);		SingleImageView -> SetPanXY (pos.h, pos.v);			/* 	Step 2:  Draw the image view				 */		#ifdef NOTYET		if (! Button())		{			WebImageApp::InDrawing = true;	//fix			CallBack();	//fix		}		#endif		#ifdef USE_PROFILER		if (! ProfilerInitialized)		{			if (ProfilerInit (collectDetailed, bestTimeBase, 30, 10))				SysBeep (0);								ProfilerInitialized = true;		}		#endif		#define DRAW_SLIVER		#ifdef DRAW_SLIVER		RgnHandle region = GetLocalUpdateRgn ();		Rect rRect = (**region).rgnBBox;	#ifdef USE_PROFILER	ProfilerSetStatus (true);	#endif		SingleImageView -> Draw (rRect.left, rRect.top, rRect.right, rRect.bottom);	#ifdef USE_PROFILER	ProfilerSetStatus (false);	#endif		DisposeRgn (region);		#else		SingleImageView -> Draw();		#endif	}//	WebImageApp::InDrawing = false;	fix}/*------------------------------------------------------------------------------  ResizeFrameBy needs to report the new Window Size to the image object  -------------------------------------------------------------------------------*/voidCommImageView::ResizeFrameBy (Int16 inWidthDelta, Int16 inHeightDelta, Boolean inRefresh){	Rect rect;//	LView::ResizeFrameBy (inWidthDelta, inHeightDelta, inRefresh);	LView::ResizeFrameBy (inWidthDelta, inHeightDelta, false);	CalcLocalFrameRect (rect);	SingleImageView -> SetWindowSize ((rect.right - rect.left), (rect.bottom - rect.top));	Int32 panX, panY;	SingleImageView -> GetPanXY (panX, panY);	Scroller -> SetScrollBars (panX, panY);}/*------------------------------------------------------------------------------------- DeActivateSelf sets up things for when the window is not active...  --------------------------------------------------------------------------------------*/void CommImageView::DeActivateSelf (void){	// PaletteSet = false;  ?? }/*-------------------------------------------------------------------------------------Prints out the Image Object--------------------------------------------------------------------------------------*/void CommImageView::Print (void){	const kDontScaleOutput = nil;	THPrint printRecordH = (THPrint) ::NewHandle (sizeof (TPrint));	::PrOpen ();	::PrintDefault (printRecordH);	if (::PrJobDialog (printRecordH))	{		TPPrPort printPort = ::PrOpenDoc (printRecordH, nil, nil);		::PrOpenPage (printPort, kDontScaleOutput);		Rect pictureRect = (**printRecordH).prInfo.rPage;		/*  Request the image to be printed  */		Rect rect  = (printPort -> gPort).portRect;		int width  = rect.right - rect.left;		int height = rect.bottom - rect.top;		int xOrigin = (width  - (width >> 1) >> 1); 		int yOrigin = (height - (height >> 1) >> 1); 			G42DrawLocation location = (G42DrawLocation) &printPort -> gPort;		GrafPtr grafPtr = (GrafPtr) printPort;		G42Image * image = SingleImageView->GetImage();		G42Image transImage(*image);		image->ClearTransparency();		SingleImageView -> DrawImageOnly ((GWorldPtr) &printPort -> gPort, GImage,			xOrigin, yOrigin, width >> 1, height >> 1);		*image = transImage;		::PrClosePage (printPort);		::PrCloseDoc (printPort);			TPrStatus printStatus;		if ((**printRecordH).prJob.bJDocLoop == bSpoolLoop)			::PrPicFile (printRecordH, nil, nil, nil, &printStatus);	}	::PrClose ();	::DisposeHandle ((Handle) printRecordH);}/*-------------------------------------------------------------------------------  SetZoom is responsible for dealing with zoom changes--------------------------------------------------------------------------------*/void CommImageView::SetZoom (float zoom){	Zoom = zoom;	/*  Step 1:  Calculate the new view image size  			*/	int imageWidth 	= GImage -> GetInfo().Width;	int imageHeight = GImage -> GetInfo().Height;	int newWidth 	= (int) ((float) imageWidth * Zoom);	int newHeight 	= (int) ((float) imageHeight * Zoom);	ResizeImageTo (newWidth + (sWindowBorder << 1), 			newHeight + (sWindowBorder << 1), true); 		/* Step 2: Deal with possible window resize... (Not yet)	*/	/* Step 3: Set image view's zoom & PowerPlant's scrollbars 	*/	Int32 panX, panY;	SingleImageView -> SetZoom (Zoom);	SingleImageView -> GetPanXY (panX, panY);	Scroller -> SetScrollBars (panX, panY); 	/* Step 4: Refresh (simple)									*/ 	Draw (nil);}/*-------------------------------------------------------------------------------  Miscellaneous initialization things that can't be done in the constructor--------------------------------------------------------------------------------*/void CommImageView::FinishCreateSelf (void){	Window = GetWindowFromView (this);	Scroller = (CommActiveScroller *) Window -> FindPaneByID ('SCRL'); }#ifdef USE_THREADSvoid CommImageView::CallBack (void){	if (UEnvironment::HasFeature (env_HasThreadsManager))		(void) ::YieldToThread (kNoThreadID);}#endif/*-------------------------------------------------------------------------------  Returns the LWindow which contains the view parameter--------------------------------------------------------------------------------*/LWindow*CommImageView::GetWindowFromView (LView *view){	LView *tempView = view;	while (tempView) 	{		tempView = tempView -> GetSuperView ();		if (tempView)			view = tempView;	}	return ((LWindow *) view);}G42Image*CommImageView::GetImage (void){	return GImage;}G42SingleImageViewer*CommImageView::GetImageViewer (void){	return SingleImageView;}voidCommImageView::AdjustCursorSelf (Point inPortPt, const EventRecord &inMacEvent){	// NEED TO FIGURE OUT WHAT GOES IN HERE FOR DEFAULT OPERATION...}void CommImageView::ClickSelf (const SMouseDownEvent &inMouseDown){	if (! IsActive())		Activate();	FocusDraw(); 	int button = (inMouseDown.macEvent.modifiers & optionKey) ? 3 : 1;	int count = ClickTimesAreClose (LastClickTime) ? 1 : 0;	SingleImageView -> MouseDown (inMouseDown.whereLocal.h, 		inMouseDown.whereLocal.v, button, false, false, count);		Point oldMouse = inMouseDown.whereLocal;	{		Point newMouse = oldMouse;		while (Button()) 		{			GetMouse (&newMouse);			#if 0			short xx = newMouse.h;			short yy = newMouse.v;			#endif			if (! EqualPt (newMouse, oldMouse)) 				SingleImageView -> MouseMove (newMouse.h, newMouse.v, false, false);				oldMouse = newMouse;		}		SingleImageView -> MouseUp (newMouse.h, newMouse.v, 1, false, false);	}	LastClickTime = inMouseDown.macEvent.when;}BooleanCommImageView::ClickTimesAreClose (Uint32 inLastClickTime){	return ((sWhenLastMouseDown - inLastClickTime) <= GetDblTime());}void CommImageView::SpendTime (const EventRecord & inMacEvent){		if (FocusExposed())	{		if (G42MarchingAnts::BeginMarch())			SingleImageView -> DrawIdle();		G42MarchingAnts::EndMarch();	}}/*-----------------------------------------------------------*/#ifdef DONTNEEDBoolean CommImageView::IsDirty() {return mIsDirty;}void CommImageView::SetDirty (Boolean inDirty) {mIsDirty = inDirty;}#endif